package scoring

import (
	"fmt"
	"strings"

	"pomelo-wishlist/internal/domain"
)

// ScoringService implements the scoring logic based on the decision matrix
type ScoringService struct{}

func NewScoringService() *ScoringService {
	return &ScoringService{}
}

func (s *ScoringService) CalculateScore(initiative *domain.Initiative) (*domain.ScoreBreakdown, error) {
	if initiative == nil {
		return nil, fmt.Errorf("initiative cannot be nil")
	}

	breakdown := &domain.ScoreBreakdown{}

	// Apply hard rules first
	if initiative.Category == domain.CategoryNewProduct {
		breakdown.TotalScore = 999999 // Goes directly to committee
		breakdown.Explanation = "Nueva categoría de producto - va directo a comité"
		return breakdown, nil
	}

	if initiative.SystemicRisk == domain.RiskBlocker {
		breakdown.TotalScore = 999998 // Maximum priority
		breakdown.RiskScore = 200
		breakdown.Explanation = "Riesgo sistémico bloqueante - prioridad máxima"
		return breakdown, nil
	}

	// Calculate individual scores
	breakdown.CategoryScore = s.calculateCategoryScore(initiative.Category)
	breakdown.VerticalScore = s.calculateVerticalScore(initiative.Category, initiative.Vertical)
	breakdown.ClientScore = s.calculateClientScore(initiative.ClientType)
	breakdown.CountryScore = s.calculateCountryScore(initiative.Countries)
	breakdown.RiskScore = s.calculateRiskScore(initiative.SystemicRisk)
	breakdown.EconomicScore = s.calculateEconomicScore(initiative.EconomicImpactType)
	breakdown.ExperienceScore = s.calculateExperienceScore(initiative.ExperienceImpact)
	breakdown.InnovationScore = s.calculateInnovationScore(initiative.InnovationLevel)

	// Calculate total score
	breakdown.TotalScore = breakdown.CategoryScore +
		breakdown.VerticalScore +
		breakdown.ClientScore +
		breakdown.CountryScore +
		breakdown.RiskScore +
		breakdown.EconomicScore +
		breakdown.ExperienceScore +
		breakdown.InnovationScore

	// Generate explanation
	breakdown.Explanation = s.generateExplanation(breakdown, initiative)

	return breakdown, nil
}

func (s *ScoringService) calculateCategoryScore(category domain.Category) int {
	switch category {
	case domain.CategoryRegulatory:
		return 30
	case domain.CategoryRisk:
		return 30
	case domain.CategoryPerformance:
		return 30
	case domain.CategoryValueProp:
		return 20
	case domain.CategoryNewProduct:
		return 200 // Special flag
	default:
		return 0
	}
}

func (s *ScoringService) calculateVerticalScore(category domain.Category, vertical domain.Vertical) int {
	// Only applies to Regulatory and Performance categories
	if category != domain.CategoryRegulatory && category != domain.CategoryPerformance {
		return 0
	}

	switch vertical {
	case domain.VerticalBanking:
		return 35
	case domain.VerticalRetail:
		return 30
	case domain.VerticalGovernment:
		return 25
	case domain.VerticalHealthcare:
		return 20
	case domain.VerticalEducation:
		return 15
	default:
		return 10
	}
}

func (s *ScoringService) calculateClientScore(clientType domain.ClientType) int {
	switch clientType {
	case domain.ClientTopIssuer:
		return 50
	case domain.ClientMajor:
		return 25
	case domain.ClientMedium:
		return 15
	case domain.ClientSmall:
		return 10
	case domain.ClientStartup:
		return 5
	default:
		return 0
	}
}

func (s *ScoringService) calculateCountryScore(countries []string) int {
	if len(countries) == 0 {
		return 0
	}

	// Find max score among countries
	maxScore := 0
	for _, countryStr := range countries {
		countryStr = strings.TrimSpace(countryStr)
		score := s.getCountryScore(domain.Country(countryStr))
		if score > maxScore {
			maxScore = score
		}
	}
	return maxScore
}

func (s *ScoringService) getCountryScore(country domain.Country) int {
	switch country {
	case domain.CountryBrazil:
		return 25
	case domain.CountryMexico:
		return 20
	case domain.CountryArgentina:
		return 15
	case domain.CountryColombia:
		return 10
	case domain.CountryChile:
		return 10
	case domain.CountryPeru:
		return 5
	default:
		return 5
	}
}

func (s *ScoringService) calculateRiskScore(risk domain.RiskLevel) int {
	switch risk {
	case domain.RiskBlocker:
		return 200
	case domain.RiskHigh:
		return 30
	case domain.RiskMedium:
		return 15
	case domain.RiskLow:
		return 5
	default:
		return 0
	}
}

func (s *ScoringService) calculateEconomicScore(impact domain.EconomicImpactType) int {
	switch impact {
	case domain.EconomicImpactSignificant:
		return 70
	case domain.EconomicImpactModerate:
		return 30
	case domain.EconomicImpactLow:
		return 0
	case domain.EconomicImpactHardToQuantify:
		return 0
	default:
		return 0
	}
}

func (s *ScoringService) calculateExperienceScore(impact domain.ExperienceImpact) int {
	score := 0

	if impact.ImproveOnboarding {
		score += 15
	}
	if impact.ReduceFriction {
		score += 15
	}
	if impact.EnhanceSecurity {
		score += 15
	}
	if impact.ImprovePerformance {
		score += 15
	}
	if impact.AddNewFeatures {
		score += 15
	}
	if impact.ImproveAccessibility {
		score += 15
	}

	return score
}

func (s *ScoringService) calculateInnovationScore(innovation domain.InnovationLevel) int {
	switch innovation {
	case domain.InnovationDisruptive:
		return 55
	case domain.InnovationIncremental:
		return 35
	case domain.InnovationParity:
		return 10
	default:
		return 0
	}
}

func (s *ScoringService) generateExplanation(breakdown *domain.ScoreBreakdown, initiative *domain.Initiative) string {
	var explanation strings.Builder

	explanation.WriteString(fmt.Sprintf("Puntaje total: %d\n\n", breakdown.TotalScore))

	explanation.WriteString("Desglose por dimensión:\n")
	explanation.WriteString(fmt.Sprintf("• Categoría (%s): %d puntos\n", initiative.Category, breakdown.CategoryScore))

	if breakdown.VerticalScore > 0 {
		explanation.WriteString(fmt.Sprintf("• Vertical (%s): %d puntos\n", initiative.Vertical, breakdown.VerticalScore))
	}

	explanation.WriteString(fmt.Sprintf("• Tipo de cliente (%s): %d puntos\n", initiative.ClientType, breakdown.ClientScore))
	explanation.WriteString(fmt.Sprintf("• País: %d puntos\n", breakdown.CountryScore))
	explanation.WriteString(fmt.Sprintf("• Riesgo sistémico (%s): %d puntos\n", initiative.SystemicRisk, breakdown.RiskScore))
	explanation.WriteString(fmt.Sprintf("• Impacto económico (%s): %d puntos\n", initiative.EconomicImpactType, breakdown.EconomicScore))
	explanation.WriteString(fmt.Sprintf("• Impacto en experiencia: %d puntos\n", breakdown.ExperienceScore))
	explanation.WriteString(fmt.Sprintf("• Innovación (%s): %d puntos\n", initiative.InnovationLevel, breakdown.InnovationScore))

	// Add contextual insights
	if breakdown.TotalScore >= 200 {
		explanation.WriteString("\nEsta iniciativa tiene alta prioridad debido a su puntaje elevado.")
	} else if breakdown.TotalScore >= 100 {
		explanation.WriteString("\nEsta iniciativa tiene prioridad media.")
	} else {
		explanation.WriteString("\nEsta iniciativa tiene prioridad baja según la matriz de decisión.")
	}

	return explanation.String()
}

// PrioritizeInitiatives sorts initiatives by score and applies tiebreaker rules
func (s *ScoringService) PrioritizeInitiatives(initiatives []*domain.Initiative) []*domain.Initiative {
	if len(initiatives) <= 1 {
		return initiatives
	}

	// Create a copy to avoid modifying the original slice
	result := make([]*domain.Initiative, len(initiatives))
	copy(result, initiatives)

	// Sort by total score (descending), then by confidence (descending), then by effort (ascending)
	for i := 0; i < len(result)-1; i++ {
		for j := i + 1; j < len(result); j++ {
			if s.shouldSwap(result[i], result[j]) {
				result[i], result[j] = result[j], result[i]
			}
		}
	}

	return result
}

func (s *ScoringService) shouldSwap(a, b *domain.Initiative) bool {
	scoreA := 0
	scoreB := 0

	if a.ScoreBreakdown != nil {
		scoreA = a.ScoreBreakdown.TotalScore
	}
	if b.ScoreBreakdown != nil {
		scoreB = b.ScoreBreakdown.TotalScore
	}

	// Primary sort: by total score (descending)
	if scoreA != scoreB {
		return scoreA < scoreB
	}

	// Tiebreaker 1: higher confidence
	if a.TechnicalEstimation.ConfidenceLevel != b.TechnicalEstimation.ConfidenceLevel {
		return a.TechnicalEstimation.ConfidenceLevel < b.TechnicalEstimation.ConfidenceLevel
	}

	// Tiebreaker 2: lower effort
	return a.TechnicalEstimation.EffortWeeks > b.TechnicalEstimation.EffortWeeks
}
